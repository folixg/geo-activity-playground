{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>I like to be outside and I like to record my outdoor activities with a GPX tracker. So far I have kept all my data with Strava and did some analyses there and also with Statshunters. This is already pretty nice.</p> <p>There are some things which they don't offer, so I want to have a place to implement them. Also I want to support the option of using only local data. This makes this project attractive for people who have a stash of GPX or FIT files but no nice way to analyze their data.</p> <p>The goal of this project is to import data either from local GPX/FIT files or the Strava API and provide some interesting insights into the data.</p> <p>You can find the code on GitHub where you can also file issues. If you would like to use this yourself or contribute, feel free to reach out via the contact options from my website. I would especially appreciate improvements to the documentation. If you're familiar with Markdown and GitHub, you can also directly create a pull request.</p> <p>This project is still in a early prototyping phase, I'm still changing a lot and some fundamental decisions are still not finally settled. So please keep in mind that it is all pretty brittle.</p>"},{"location":"explorer-tiles/","title":"Explorer Tiles","text":""},{"location":"explorer-tiles/#what-are-explorer-tiles","title":"What are explorer tiles?","text":"<p>Maps accessible via the web browser are usually served as little image tiles. The Open Street Map uses the Web Mercator coordinate system to map from latitude and longitude to pixels on the map.</p> <p>Each tile is 256 \u00d7 256 pixels in size. The zoom levels zoom in by a factor of two. Therefore all the tiles are organized in a quad tree. As you zoom in, each tile gets split into four tiles which can then show more detail. The following prescription maps from latitude and longitude (given in degrees) to tile indices:</p> <pre><code>def compute_tile(lat: float, lon: float, zoom: int = 14) -&gt; tuple[int, int]:\n    x = np.radians(lon)\n    y = np.arcsinh(np.tan(np.radians(lat)))\n    x = (1 + x / np.pi) / 2\n    y = (1 - y / np.pi) / 2\n    n = 2**zoom\n    return int(x * n), int(y * n)\n</code></pre> <p>At zoom level 14 the tiles have a side length of roughly 1.5 km where I live. These tiles are used as the basis for explorer tiles. The basic idea is that every tile where you have at least one point in an activity is considered an explored tile.</p> <p>From your activities the program will extract all the tiles that you have visited. And then it does a few things with those.</p>"},{"location":"explorer-tiles/#maps-with-explorer-tiles","title":"Maps with explorer tiles","text":"<p>The most straightforward artifact is a map with all the tiles that you have explored. This is created in the GeoJSON format as that can encode polygons. You can then take a look at these maps with programs like GPXSee or online viewers like GeoJSON.io.</p> <p>The explored tiles map looks like this for the Hunsr\u00fcck area for me:</p> <p></p>"},{"location":"explorer-tiles/#missing-tiles","title":"Missing tiles","text":"<p>The next interesting question are the missing tiles. I often have little gaps and would like to see them easily. The program computes the boundary around the tiles that you have explored. This can be used to plan extensions of the explored area.</p> <p></p> <p>On Android one can use the OsmAnd app to display tracks and also try to visualize the missing tiles. Unfortunately GeoJSON is not supported, therefore one has to play some tricks. The missing tiles are also exported as a GPX file with a track for each missing tile. This looks strange, but it is a bit helpful with OsmAnd. This is how the file looks like in GPXSee:</p> <p></p> <p>Transfer this GPX file to OsmAnd and you can have it display the missing tiles such that you can extend your explored area systematically.</p>"},{"location":"heatmaps/","title":"Heatmaps","text":"<p>From all the points in your activities, one can generate nice heatmaps. This builds on the Strava local heatmap code.</p> <p>We don't generate a single heatmap for all your activities as this will not look great as soon as you have done an activity away from home. Rather we use a clustering algorithm to find all disjoint geographical clusters in your activities and generate one heatmap per cluster.</p> <p>For instance the heatmap generated from all my activities in the Randstad in the Netherlands:</p> <p></p>"},{"location":"explanation/explorer-tiles/","title":"Explorer Tiles","text":"<p>Maps accessible via the web browser are usually served as little image tiles. The Open Street Map uses the Web Mercator coordinate system to map from latitude and longitude to pixels on the map.</p> <p>Each tile is 256\u00d7256 pixels in size. The zoom levels zoom in by a factor of two. Therefore all the tiles are organized in a quad tree. As you zoom in, each tile gets split into four tiles which can then show more detail. The following prescription maps from latitude and longitude (given in degrees) to tile indices:</p> <pre><code>def compute_tile(lat: float, lon: float, zoom: int = 14) -&gt; tuple[int, int]:\n    x = np.radians(lon)\n    y = np.arcsinh(np.tan(np.radians(lat)))\n    x = (1 + x / np.pi) / 2\n    y = (1 - y / np.pi) / 2\n    n = 2**zoom\n    return int(x * n), int(y * n)\n</code></pre> <p>At zoom level 14 the tiles have a side length of roughly 1.5 km in Germany. These tiles are used as the basis for explorer tiles. The basic idea is that every tile where you have at least one point in an activity is considered an explored tile.</p> <p>From your activities the program will extract all the tiles that you have visited. And then it does a few things with those. One main thing is that it will display these on an interactive map. When we zoom into one area where I've been on vacation in 2023, you can see the explored tiles there:</p> <p></p> <p>The colored tiles are explored, I have been there. The green tiles are cluster tiles, that means that all their four neighbor tiles are also explored.</p> <p>You can see here how I have explored a region and ensured that it is mostly contiguous.</p> <p>There is another vacation from 2013 where I wasn't aware of the cluster tiles. I just did some bike trips and didn't look out for the tiles. There the tiles look like this:</p> <p></p> <p>You see all these gaps in there. And this is what the explorer tiles are about: This OCD (obsessive compulsive disorder) like craving to fill in the gaps.</p> <p>Let's take a look at my main cluster of explorer tiles. Here I have explored much more than in the areas where I was on vacation.</p> <p></p> <p>You can see an additional feature, the blue square. This is the one largest square which can be fit into all explored tiles. In this picture it has size 21\u00b2. The idea of the square is to have a really tough challenge. Not only does one need to explore increasingly many tiles to expand the square by one unit, there must not be any gaps.</p> <p>As you can see in this picture, there is a tile missing right at the top edge. I will never be able to get that because that is an off-limits area of the German air force at the airport. So I can expand my square to the south only.</p>"},{"location":"getting-started/installing-git-on-linux/","title":"Installing Git Version On Linux","text":"<p>As this project is still in development, you might want to have a peek into the development version. This is more advanced than using the stable versions, but not impossibly hard.</p> <p>First you need to clone the git repository from GitHub using the following command:</p> <pre><code>git clone https://github.com/martin-ueding/geo-activity-playground.git\n</code></pre> <p>That will create a directory <code>geo-activity-playground</code> in your current working directory.</p> <p>Then change into that directory:</p> <pre><code>cd geo-activity-playground\n</code></pre> <p>Next we will use Poetry to install the dependencies of the project. First you need to make sure that you have Poetry available. On Ubuntu/Debian run <code>sudo apt install python3-poetry</code>, on Fedora/RedHat run <code>sudo dnf install poetry</code> to install it.</p> <p>Then we can create the virtual environment:</p> <pre><code>poetry install\n</code></pre> <p>And next we can run the program:</p> <pre><code>poetry run geo-activity-playground --basedir path/to/your/playground --help\n</code></pre> <p>Replace the <code>--help</code> with the subcommands described in the help message or the other parts described this documentation.</p> <p>You will need the <code>--basedir</code> option because you run the program from the source directory and not from your playground directory. If you install the stable version via PIP as described in the other page, you will not need this option.</p>"},{"location":"getting-started/installing-git-on-linux/#updating-to-the-latest-version","title":"Updating to the latest version","text":"<p>Over time I will add more commits to the source control system. In order to update your clone to the latest version, execute the following:</p> <pre><code>git pull\n</code></pre> <p>This will download the missing changesets and apply them to your downloaded version. After that is done, you need to update your virtual environment with this:</p> <pre><code>poetry install\n</code></pre> <p>And then you can continue using it as before.</p>"},{"location":"getting-started/installing-stable-on-linux/","title":"Installing Stable On Linux","text":"<p>In this how-to guide I will show you how you can install the latest stable version of this project on Linux.</p> <p>Using PIP, you can install the latest version using this command:</p> <pre><code>pip install --user geo-activity-playground\n</code></pre> <p>If you get an error about the command <code>pip</code> not found, you will need to install that first. On Ubuntu or Debian use <code>sudo apt install python3-pip</code>, on Fedora or RedHat use <code>sudo dnf install python3-pip</code>. After you have installed PIP, repeat the above command.</p>"},{"location":"getting-started/installing-stable-on-linux/#ensure-that-the-path-is-correct","title":"Ensure that the PATH is correct","text":"<p>Next you can try to start the program by just entering the following into the terminal:</p> <pre><code>geo-activity-playground --help\n</code></pre> <p>If you get a help message, everything is fine. If you get an error about command not found, we need to adjust your PATH. Execute the following in your command line:</p> <pre><code>xdg-open ~/.profile\n</code></pre> <p>This brings up an editor with your shell profile. Add a line containing the following at the end of the file:</p> <pre><code>PATH=$PATH:$HOME/.local/bin\n</code></pre> <p>This adds the path to your shell environment. After you have done it, close your terminal window and open a new one. Try the first command in this section again, you should see the help message now.</p>"},{"location":"getting-started/installing-stable-on-linux/#upgrading-to-the-latest-version","title":"Upgrading to the latest version","text":"<p>At some later point you likely want to upgrade to the latest version. For this use this command:</p> <pre><code>pip install --user --upgrade geo-activity-playground\n</code></pre>"},{"location":"getting-started/starting-the-webserver/","title":"Starting The Webserver","text":"<p>Before you start here, you should have done these things:</p> <ul> <li>You have installed the program either from a stable version or from git.</li> <li>You have set up a playground with either activity files or the Strava API.</li> </ul> <p>Now we can start the webserver which provides most of the features. This is done with the <code>serve</code> command. So depending on how you have installed it, the commands could look like these:</p> <ul> <li><code>geo-activity-playground --source strava-api serve</code> if you are in the playground directory and have installed a stable version.</li> <li><code>poetry run geo-activity-playground --source directory --basedir ~/Dokumente/Karten/Playground serve</code> if you have it from the git checkout and want to use local files in your directory as a data source.</li> </ul> <p>The webserver will start up and give you a bit of output like this:</p> <pre><code>2023-11-19 17:59:23 geo_activity_playground.importers.strava_api INFO Loading metadata file \u2026\n2023-11-19 17:59:23 stravalib.protocol.ApiV3 INFO GET 'https://www.strava.com/api/v3/athlete/activities' with params {'before': None, 'after': 1700392964, 'page': 1, 'per_page': 200}\n2023-11-19 17:59:23 geo_activity_playground.importers.strava_api INFO Checking for missing time series data \u2026\n * Serving Flask app 'geo_activity_playground.webui.app'\n * Debug mode: off\n2023-11-19 17:59:23 werkzeug INFO WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.\n * Running on http://127.0.0.1:5000\n2023-11-19 17:59:23 werkzeug INFO Press CTRL+C to quit\n</code></pre> <p>The warning about the development server is fine. We are using this only to play around, not to power a web service for other users.</p> <p>Open http://127.0.0.1:5000 to open the website in your browser. There might be some more messages about downloading and parsing data. The first startup will take quite some time. When it is done you will see something like this:</p> <p></p> <p>Click around and explore the various features.</p>"},{"location":"getting-started/using-activity-files/","title":"Using Activity Files","text":"<p>Outdoor activities are usually recorded as GPX or FIT files. Some apps like OsmAnd give you these files.</p> <p>Create a directory somewhere, this will be your playground. I have mine in <code>~/Dokumente/Karten/Playground</code>, but you can put yours wherever you would like.</p> <p>Inside <code>Playground</code>, create another directory <code>Activities</code>. You can create an arbitrary directory structure below that, at the moment it doesn't have any meaning. I do plan to give it meaning at some point and think about a structure like <code>Playground/Activities/{Activity Type}/{Equipment}/{year}-{month}-{day}-{hour}-{minute}-{name}.gpx</code>. Then the activity type would be things like ride, run, walk, hike. The equipment would be the name for bikes or shoes such that one can aggregate distances per equipment. Perhaps one could add another subdirectory <code>Commute</code> such that all the repetitive commutes could go into there.</p> <p>Either way, at the moment we only really need <code>Playground/Activities/{name}.gpx</code> (or <code>.fit</code>).</p> <p>Once you have your files there, you can proceed with the next steps.</p> <p>When starting the program, you need to supply the argument <code>--source directory</code> to select the activity files as your source.</p>"},{"location":"getting-started/using-strava-api/","title":"Using Strava API","text":"<p>You might have all your data on the Strava service and would like to use this for additional analytics without moving your data. That is fine.</p> <p>In order to use the Strava API, one needs to create an app. If my explanation doesn't suit you, have a look at this how-to guide as well.</p> <p>Navigate to the API settings page and create an app. It only needs to have read permissions.</p> <p>After you are done with that, you can see your App here:</p> <p></p> <p>There is a client ID that we are going to need for the next step. In general our app could be used by all sorts of people who can then access their data only. We want to access our own data, but we still need to authorize our app to use our data. In order to get this token, we need to visit the following URL, with <code>{client_id}</code> replaced by your ID.</p> <pre><code>https://www.strava.com/oauth/authorize?client_id={client_id}&amp;redirect_uri=http://localhost&amp;response_type=code&amp;scope=activity:read_all\n</code></pre> <p>This will prompt an OAuth2 request where you have to grant permissions to your app. After that you will be redirected to localhost and see a \u201cpage not found\u201d error. That is all okay!</p> <p>Take a look at the URL. It look like this:</p> <pre><code>http://localhost/?state=&amp;code={code}&amp;scope=read,activity:write,activity:read_all\n</code></pre> <p>From the URL you can read off the code. Now you have all the three data points that you need. Create the file <code>Playground/config.toml</code> with a text editor and fill in this template:</p> <pre><code>[strava]\nclient_id = \"\u2026\"\nclient_secret = \"\u2026\"\ncode = \"\u2026\"\n</code></pre> <p>Add the client ID and the client secret from your Strava app. Add the code that we have read off this localhost URL.</p> <p>Then you are all set to download data from the Strava API. Select the Strava API by supplying <code>--source strava-api</code> to the commands.</p>"},{"location":"getting-started/using-strava-api/#rate-limiting","title":"Rate limiting","text":"<p>When you first start this program and use the Strava API as a data source, it will download the metadata for all your activities. Then it will start to download all the time series data for each activity. Strava has a rate limiting, so after the first 200 activities it will crash and you will have to wait for 15 minutes until you can try again and it will download the next batch.</p>"},{"location":"reference/changelog/","title":"Changelog","text":"<p>This is the log of high-level changes that I have done in the various versions.</p>"},{"location":"reference/changelog/#version-0","title":"Version 0","text":"<p>This is the pre-release series. Things haven't settled yet, so each minor version might introduce breaking changes.</p>"},{"location":"reference/changelog/#version-06","title":"Version 0.6","text":"<ul> <li>Interactive map for each activity.</li> <li>Color explorer tiles in red, green and blue.</li> <li>Directly serve GeoJSON and Vega JSON embedded in the document.</li> </ul>"},{"location":"reference/changelog/#version-05","title":"Version 0.5","text":"<ul> <li>Add some plots for the Eddington number.</li> </ul>"},{"location":"reference/changelog/#version-04","title":"Version 0.4","text":"<ul> <li>Add some more plots.</li> </ul>"},{"location":"reference/changelog/#version-03","title":"Version 0.3","text":"<ul> <li>Start to build web interface with Flask.</li> <li>Remove tqdm progress bars and use colorful logging instead.</li> <li>Add interactive explorer tile map.</li> </ul>"},{"location":"reference/changelog/#version-02","title":"Version 0.2","text":"<ul> <li>Unity command line entrypoint.</li> <li>Crop heatmaps to fit.</li> <li>Export missing tiles as GeoJSON.</li> <li>Add Strava API.</li> <li>Add directory source.</li> </ul>"},{"location":"reference/changelog/#version-01","title":"Version 0.1","text":""},{"location":"reference/changelog/#version-013","title":"Version 0.1.3","text":"<ul> <li>Generate some heatmap images.</li> <li>Generate an explorer tile video.</li> </ul>"},{"location":"reference/directory-layout/","title":"Directory Layout","text":"<p>There are a bunch of files that need to be given to this set of scripts, are used as intermediate files or generated as output. In order to make it clear where everything is, the following document lists all the paths which are relevant to the script.</p> <p>Everything is relative to a base directory which can be passed with the <code>--basedir</code> option to the scripts.</p>"},{"location":"reference/directory-layout/#input","title":"Input","text":"<p>The user has to put data into the following directories in order for it to be picked up.</p> <ul> <li> <p><code>Strava Export</code>: Contains the exported data from Strava.</p> </li> <li> <p><code>config.toml</code>: Configuration file</p> </li> </ul>"},{"location":"reference/directory-layout/#output-and-cache","title":"Output and cache","text":"<p>The following directories serve as a cache. One can inspect this but doesn't need to work with that directly.</p> <ul> <li> <p><code>Explorer</code>: Things related to the explorer tiles.</p> <ul> <li><code>Per Activity</code>: A data frame with the tiles that have been visited within each activity. Each file is named with the activity ID like <code>2520340514.parquet</code>. The columns are <code>time</code>, <code>tile_x</code>, <code>tile_y</code>.</li> <li><code>first_time_per_tile.parquet</code>: A data frame with the first visit datetime for each explorer tile. Columns <code>time</code>, <code>tile_x</code>, <code>tile_y</code>.</li> <li><code>missing_tiles.geojson</code>: A GeoJSON file with square polygons for all missing tiles at the boundary of explored tiles.</li> <li><code>missing_tiles.gpx</code>: The same, just expressed as square tracks in the GPX format.</li> <li><code>explored.geojson</code>: A GeoJSON file with square polygons for all explored tiles.</li> <li><code>explored.gpx</code>: The same, just expressed as square tracks in the GPX format.</li> </ul> </li> <li> <p><code>Heatmaps</code>: Will contain heatmap images generated from the data. They will be called like <code>Cluster-{i}.png</code> with increasing numbers. When one re-generates the heatmaps, the old files will be deleted to make sure that even if the numbers of clusters has been reduced there are no old files remaining.</p> </li> <li> <p><code>Open Street Map Tiles</code>: Cached tiles from the Open Street Map. The substructure is <code>{zoom}/{x}/{y}.png</code>. Each image has a size of 256\u00d7256 pixels.</p> </li> <li> <p><code>Strava API</code>: Everything that is downloaded via the Strava API is stored in this subtree.</p> <ul> <li><code>Data</code>: The time series data for each activity as a data frame stored in the Parquet format. Filenames are <code>{activity_id}.parquet</code> with the activity IDs. The column names are the following: <code>time</code>, <code>latitude</code>, <code>longitude</code> and optionally <code>distance</code>, <code>altitude</code>, <code>heartrate</code>.</li> <li><code>Metadata</code>: The activity objects from the <code>stravalib</code> Python library are stored here as Python pickle objects. The file names are time stamp of the activity start, like <code>start-{timestamp}.pickle</code>.</li> <li><code>strava_tokens.json</code>: Tokens for the Strava API. Contains the access and refresh tokens.</li> </ul> </li> <li> <p><code>Strava Export Cache</code>: Caching directory for files derived from the Strava export.</p> <ul> <li><code>Activities</code>: Same as <code>Strava API/Data</code>.</li> </ul> </li> </ul>"}]}